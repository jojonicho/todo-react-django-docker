"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var sheet = require("@emotion/sheet"), stylis = require("stylis"), weakMemoize = _interopDefault(require("@emotion/weak-memoize")), toRules = function(parsed, points) {
  var index = -1, character = 44;
  do {
    switch (stylis.token(character)) {
     case 0:
      parsed[index] += stylis.identifier(stylis.position - 1);
      break;

     case 2:
      parsed[index] += stylis.delimit(character);
      break;

     case 4:
      if (44 === character) {
        parsed[++index] = 58 === stylis.peek() ? "&\f" : "", points[index] = parsed[index].length;
        break;
      }

     default:
      parsed[index] += stylis.from(character);
    }
  } while (character = stylis.next());
  return parsed;
}, getRules = function(value, points) {
  return stylis.dealloc(toRules(stylis.alloc(value), points));
}, compat = function(element) {
  if ("rule" === element.type && element.parent && element.length) {
    var value = element.value;
    if (1 !== element.props.length || 58 === value.charCodeAt(0)) {
      var parent = element;
      do {
        parent = parent.parent;
      } while ("rule" !== parent.type);
      for (var points = [], rules = getRules(value, points), parentRules = parent.props, i = 0, k = 0; i < rules.length; i++) for (var j = 0; j < parentRules.length; j++, 
      k++) points[i] && (element.props[k] = rules[i].replace(/&\f/g, parentRules[j]));
    }
  }
}, removeLabel = function(element) {
  if ("decl" === element.type) {
    var value = element.value;
    108 === value.charCodeAt(0) && 98 === value.charCodeAt(2) && (element.return = "", 
    element.value = "");
  }
}, isBrowser = "undefined" != typeof document, getServerStylisCache = isBrowser ? void 0 : weakMemoize((function() {
  var cache = {};
  return function(name) {
    return cache[name];
  };
})), defaultStylisPlugins = [ stylis.prefixer ], movedStyles = !1, createCache = function(options) {
  var key = options.key;
  if (!key) throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  if (isBrowser && !movedStyles && "css" === key) {
    movedStyles = !0;
    var ssrStyles = document.querySelectorAll("style[data-emotion]");
    Array.prototype.forEach.call(ssrStyles, (function(node) {
      document.head.appendChild(node);
    }));
  }
  var container, _insert, stylisPlugins = options.stylisPlugins || defaultStylisPlugins, inserted = {}, nodesToHydrate = [];
  isBrowser && (container = options.container || document.head, Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion]"), (function(node) {
    var attrib = node.getAttribute("data-emotion").split(" ");
    if (attrib[0] === key) {
      for (var i = 1; i < attrib.length; i++) inserted[attrib[i]] = !0;
      nodesToHydrate.push(node);
    }
  })));
  var omnipresentPlugins = [ compat, removeLabel ];
  if (isBrowser) {
    var currentSheet, finalizingPlugins = [ stylis.stringify, stylis.rulesheet((function(rule) {
      currentSheet.insert(rule);
    })) ], serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    _insert = function(selector, serialized, sheet, shouldCache) {
      var styles;
      currentSheet = sheet, styles = selector ? selector + "{" + serialized.styles + "}" : serialized.styles, 
      stylis.serialize(stylis.compile(styles), serializer), shouldCache && (cache.inserted[serialized.name] = !0);
    };
  } else {
    var _finalizingPlugins = [ stylis.stringify ], _serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins)), serverStylisCache = getServerStylisCache(stylisPlugins), getRules = function(selector, serialized) {
      var styles, name = serialized.name;
      return void 0 === serverStylisCache[name] && (serverStylisCache[name] = (styles = selector ? selector + "{" + serialized.styles + "}" : serialized.styles, 
      stylis.serialize(stylis.compile(styles), _serializer))), serverStylisCache[name];
    };
    _insert = function(selector, serialized, sheet, shouldCache) {
      var name = serialized.name, rules = getRules(selector, serialized);
      return void 0 === cache.compat ? (shouldCache && (cache.inserted[name] = !0), rules) : shouldCache ? void (cache.inserted[name] = rules) : rules;
    };
  }
  var cache = {
    key: key,
    sheet: new sheet.StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  return cache.sheet.hydrate(nodesToHydrate), cache;
};

exports.default = createCache;
